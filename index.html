<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<title>Neil Obby Game</title>
<style>
    body { margin:0; overflow:hidden; }
    canvas { display:block; }
</style>
</head>
<body>

<script type="module">
import * as THREE from "https://cdn.jsdelivr.net/npm/three@0.160/build/three.module.js";

//////////////////////
// SCENE SETUP
//////////////////////

const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);

const renderer = new THREE.WebGLRenderer({antialias:true});
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

//////////////////////
// LIGHTING
//////////////////////

const light = new THREE.DirectionalLight(0xffffff,1);
light.position.set(10,20,10);
scene.add(light);

scene.add(new THREE.AmbientLight(0xffffff,0.4));

//////////////////////
// PLAYER
//////////////////////

const player = new THREE.Object3D();
scene.add(player);

player.position.set(0,5,0);

const playerHeight = 2;

camera.position.set(0,playerHeight,0);
player.add(camera);

//////////////////////
// MOUSE LOOK
//////////////////////

let pitch = 0;
let yaw = 0;

document.body.addEventListener("click",()=>{
    document.body.requestPointerLock();
});

document.addEventListener("mousemove",(e)=>{

    if(document.pointerLockElement === document.body){

        yaw -= e.movementX * 0.002;
        pitch -= e.movementY * 0.002;

        pitch = Math.max(-Math.PI/2, Math.min(Math.PI/2, pitch));

        player.rotation.y = yaw;
        camera.rotation.x = pitch;
    }
});

//////////////////////
// PLATFORMS
//////////////////////

const platforms = [];
let checkpoint = new THREE.Vector3(0,5,0);

function createPlatform(x,y,z,w,h,d,color=0x00ff00){

    const geo = new THREE.BoxGeometry(w,h,d);
    const mat = new THREE.MeshStandardMaterial({color});
    const mesh = new THREE.Mesh(geo,mat);

    mesh.position.set(x,y,z);
    mesh.userData = {w,h,d};

    scene.add(mesh);
    platforms.push(mesh);
}

// SPAWN
createPlatform(0,0,0,12,1,12,0x555555);

// OBBY COURSE
createPlatform(0,3,-10,4,1,4);
createPlatform(5,6,-18,4,1,4);
createPlatform(-5,9,-26,4,1,4);
createPlatform(0,12,-34,4,1,4);
createPlatform(6,15,-42,4,1,4);
createPlatform(-6,18,-50,4,1,4);

// CHECKPOINT
const checkpointGeo = new THREE.BoxGeometry(3,1,3);
const checkpointMat = new THREE.MeshStandardMaterial({color:0xffff00});
const checkpointBlock = new THREE.Mesh(checkpointGeo,checkpointMat);
checkpointBlock.position.set(0,21,-58);
scene.add(checkpointBlock);

//////////////////////
// LAVA (KILL BLOCK)
//////////////////////

const lavaGeo = new THREE.BoxGeometry(50,1,50);
const lavaMat = new THREE.MeshStandardMaterial({color:0xff0000});
const lava = new THREE.Mesh(lavaGeo,lavaMat);
lava.position.set(0,-5,-30);
scene.add(lava);

//////////////////////
// CONTROLS
//////////////////////

const keys = {};
document.addEventListener("keydown",e=>keys[e.code]=true);
document.addEventListener("keyup",e=>keys[e.code]=false);

//////////////////////
// PHYSICS
//////////////////////

let velocityY = 0;
const gravity = -0.015;
const walkSpeed = 0.1;
const sprintSpeed = 0.18;
const jumpForce = 0.32;
let onGround = false;

//////////////////////
// COLLISION
//////////////////////

function checkCollision(){

    onGround = false;

    for(const p of platforms){

        const w = p.userData.w;
        const h = p.userData.h;
        const d = p.userData.d;

        const px = p.position.x;
        const py = p.position.y;
        const pz = p.position.z;

        const withinX =
            player.position.x > px - w/2 &&
            player.position.x < px + w/2;

        const withinZ =
            player.position.z > pz - d/2 &&
            player.position.z < pz + d/2;

        const playerBottom = player.position.y;
        const platformTop = py + h/2;

        if(
            withinX &&
            withinZ &&
            playerBottom <= platformTop + 0.2 &&
            playerBottom >= platformTop - 1 &&
            velocityY <= 0
        ){
            player.position.y = platformTop;
            velocityY = 0;
            onGround = true;
        }
    }
}

//////////////////////
// MOVEMENT
//////////////////////

function movePlayer(){

    let speed = keys["ShiftLeft"] ? sprintSpeed : walkSpeed;

    const forward = new THREE.Vector3(0,0,-1).applyQuaternion(player.quaternion);
    const right = new THREE.Vector3(1,0,0).applyQuaternion(player.quaternion);

    if(keys["KeyW"]) player.position.add(forward.clone().multiplyScalar(speed));
    if(keys["KeyS"]) player.position.add(forward.clone().multiplyScalar(-speed));
    if(keys["KeyA"]) player.position.add(right.clone().multiplyScalar(-speed));
    if(keys["KeyD"]) player.position.add(right.clone().multiplyScalar(speed));

    if(keys["Space"] && onGround){
        velocityY = jumpForce;
    }
}

//////////////////////
// RESPAWN
//////////////////////

function respawn(){
    player.position.copy(checkpoint);
    velocityY = 0;
}

//////////////////////
// GAME LOOP
//////////////////////

function animate(){

    requestAnimationFrame(animate);

    movePlayer();

    velocityY += gravity;
    player.position.y += velocityY;

    checkCollision();

    // lava check
    if(player.position.y < lava.position.y + 2){
        respawn();
    }

    // checkpoint activation
    if(
        Math.abs(player.position.x - checkpointBlock.position.x) < 2 &&
        Math.abs(player.position.z - checkpointBlock.position.z) < 2 &&
        Math.abs(player.position.y - checkpointBlock.position.y) < 3
    ){
        checkpoint = checkpointBlock.position.clone();
        checkpoint.y += 3;
        checkpointBlock.material.color.set(0x00ffff);
    }

    renderer.render(scene,camera);
}

animate();

//////////////////////
// RESIZE
//////////////////////

window.addEventListener("resize",()=>{
    camera.aspect = window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>

</body>
</html>
